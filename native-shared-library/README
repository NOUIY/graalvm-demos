#  Build a Native Shared Library

This demo shows how to create a small Java class library, use `native-image` to create a native shared library, and then create a small C application that uses that shared library.

GraalVM makes it easy to use C to call into a native shared library.
There are two primary mechanisms for calling a method (function) embedded in a native shared library: the [Native Image C API](https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/C-API/)Â and the [JNI Invocation API](https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/JNIInvocationAPI/).

This examples demonstrates how to use the **Native Image C API**. You will:

1. Create and compile a Java class library containing at least one entrypoint method.
2. Use the `native-image` tool to create a shared library from the Java class library.
3. Create and compile a C application that calls an entrypoint method in the shared library.

## Prerequisites
* [GraalVM](http://graalvm.org)
* [Native Image](https://www.graalvm.org/latest/reference-manual/native-image/)

## Preparation

1. Download and install the latest GraalVM JDK with Native Image using the [GraalVM JDK Downloader](https://github.com/graalvm/graalvm-jdk-downloader):
    ```bash
    bash <(curl -sL https://get.graalvm.org/jdk) -c 'native-image'
    ```
2. Install LLVM toolchain support to GraalVM, as follows:
    ```bash
    $JAVA_HOME/bin/gu install llvm-toolchain
    ```

    > Note: The `llvm-toolchain` GraalVM component is not available on Microsoft Windows.

3. Download or clone GraalVM demos repository and navigate into the `native-shared-library` directory:
    ```bash
    git clone https://github.com/graalvm/graalvm-demos
    cd graalvm-demos/native-shared-library
    ```
4. Compile _LibEnvMap.java_ and build a native shared library, as follows:
    ```bash
    $JAVA_HOME/bin/javac LibEnvMap.java
    ```
    ```bash
    $JAVA_HOME/bin/native-image -H:Name=LibEnvMap --shared 
    ``` 

    It will produce the following artifacts:
    ```
    --------------------------------------------------
    Produced artifacts:
    /demo/libenvmap.dylib (shared_lib)
    /demo/libenvmap.h (header)
    /demo/graal_isolate.h (header)
    /demo/libenvmap_dynamic.h (header)
    /demo/graal_isolate_dynamic.h (header)
    /demo/libenvmap.build_artifacts.txt
    ==================================================
    ```
    In the result of this process the native shared library will have the `main()` method of the given Java class as its **entrypoint** method.

    The shared library must have at least one entrypoint method. By default, only the `public static void main()` method is identified as an entrypoint and callable from a C application.
 
    If you work with C or C++, use these header files directly. For other languages, such as Java, use the function declarations in the headers to set up your foreign call bindings. 

    If your library does not include a `main()` method, use the `-H:Name=` command-line option to specify the library name, as follows:

    ```bash
    native-image --shared -H:Name=<libraryname> <class name>
    ```
    ```bash
    native-image --shared -jar <jarfile> -H:Name=<libraryname>
    ```
    Also, native shared library can be created from a JAR file using the following syntax:
    ```bash
    native-image -jar <jarfile> --shared
    ```   

5. Compile the _main.c_ using `clang`.  
    ```bash
    $JAVA_HOME/languages/llvm/native/bin/clang -I ./ -L ./ -l envmap -Wl,-rpath ./ -o main main.c 
    ```
6. Run the C application by passing a string as an argument. For example:
    ```bash
    ./main USER
    ```
    It will correctly print out the name and value of the matching environment variable(s).    


The advantage of using the [Native Image C API](https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/C-API/) is that you can determine what your API will look like. 
The restriction is that your parameter and return types must be non-object types.
If you want to manage Java objects from C, you should consider [JNI Invocation API](https://www.graalvm.org/latest/reference-manual/native-image/native-code-interoperability/JNIInvocationAPI/). 

Consider reading [this blog post](https://nirvdrum.com/2022/05/09/truffle-language-embedding.html) by Kevin Menard where he compares both mechanisms for exposing Java methods.